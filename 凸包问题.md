# Extreme Point
point set $S=\{p_1,p_2,\cdots ,p_n\}\subset D^2$
A point $p$ of $S$ is called an *Extreme Point(EP)* iff there exists a line $L$ through $P$ such that *all$ point of $S$ lie on the *same side* of $L$
A polygon is *convex* iff every vertex is extreme
# To-Left Test
ToLeft(a,b,s) is TRUE iff s lies *left* to *directed line* ab
ToLeft(p,q,s) $\to Area2(p,q,s)>0 \to |p q s|>0$
# In-Triangle Test
InTriangle(p,q,r,s) if TRUE iff ToLeft(p,q,s),ToLeft(q,r,s),ToLeft(r,p,s) are all TRUE
We can use In-Triangle Test to solve the convex hull problem in $O(n^4)$
# Extreme Edges
All points in $S$ lie tot the *same side* of *Extreme Edges(EE)*
We can enum all the edges and check all the vertexs so that we can solve the convex hull problem in $O(n^3)$
# Decrease and Conquer
We can insert the points into a convex hull one after another. Time complixity is $O(n^2)$
## In-Convex-Polygon Test(ICPT)
In static case, we can use binary-search to solve the test in $O(n\log n)$
However, in this case the convex hull is dynamic, we have to use $O(n)$ time to do In-Convex-Polygon Test
## Tangents
If ICPT returns true, for a point *$x$* exterior to the hull, there are two tangent points $s$ and $t$.
To update the hull, we simply throw *$ts$* away and connect *$x$* with *$s$ and $t$*.
Given $x$, all *current EP's* can be classified into *4 types*——*L+L:s;R+R:t;R+L:st;L+R:ts*
# Jarvis March
The stategy is finding the next EP before attaching it to a *partial convex hull*. Time complixity is $O(n^2)$
All directed EE's form a CCW cycle. Each pair of consecutive EE's *share* an endpoint.
Let *$ik$* be an EE, then get next EE *$ks$* which has *minimum* left-turn.
We can use To-Left Test to make this step $O(n)$. 
What's more, we can let the *lowest-then-leftmost(LTL)* point as the start point.
# Lower Bound
Convex Problem's lower bound is *$O(n\log n)$*
Consider a sequence $\{a_1,a_2,\cdots, a_n\}$, we make $n$ points in the dimention and let $a_i$ trans to $(a_i,a_i^2)$ and try to find the conver of the point set. We can find convex problem is at least a sorting problem, which lower bound is *O(n\log n)*. So we can learn that convex problem can't be easier than sorting problem.
# Graham Scan
## Presorting
找到LTL点$p_1$，然后对其他所有点按照对$p_1$的极角序排序并标号（排序不直接求角，会有很大精度误差，直接将cmp函数改为ToLeft测试即可）
将排好序后的$p_1,p_2$加到栈$S$中，将其余点$\{p_3,p_4,\cdots,p_n\}$依次判进行如下的判断。
## Working
假设判断的点是$p_i$在栈的第二个点和第一个点的向量的左端，即$ToLeft(S_1,S_0,p_i)$为真，将$p_i$加到$S$栈中，否则将$S$的栈顶弹出，急需判断$p_i$。因为$S$中元素肯定不会少于$2$个，故不用判断$S$中元素是否大于等于$2$个。
## Correctness
使用数学归纳法。假设按极角排好序后，到$k$个点时已经求出了前$k$个点的凸包，现在证明加入第$k+1$个点后求出的凸包是正确的，根据这个点在左手边或右手边分情况讨论分析，可以画图证明。
为什么要排序？我们可以画不断往左转的图案，容易发现不排序就会挂掉。
## Trick
一般来说，Graham扫描法的时间复杂度是$O(n\log n)$，但如果点集有序，可以达到线性复杂度。
使用Graham扫描法判断过的所有边构成一个平面图，而$n$个点的平面图边数不超过$3n$级别，故排好序后算法是线性的。
如果一开始已经按X轴排好序，我们不需要做极角排序就可以在*$O(n)$*的时间内求出凸包。考虑在Y轴的正负无穷处各有一个极点，从极点处看这些在X轴排好序的点的极角序也是排好的。那么可以用Graham扫描法做一遍*上*凸包，再做一遍*下*凸包，把两个凸包*合并*即可线性时间得到凸包。
